<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>进阶</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-01-08T03:16:00.020Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>karen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>说说使用v-for时key的作用</title>
    <link href="http://yoursite.com/2021/01/07/%E8%B0%88%E8%B0%88%E5%9C%A8%E4%BD%BF%E7%94%A8v-for%E6%97%B6key%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2021/01/07/谈谈在使用v-for时key的作用/</id>
    <published>2021-01-07T06:41:46.000Z</published>
    <updated>2021-01-08T03:16:00.020Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们在用v-for指令渲染列表时，如果没有定义 <strong>v-bind:key</strong>，那么会得到错误提示，<br>可能你会不以为然地加上就万事大吉了<br>但，在某些情况下还是要小心为妙</p><p>先来看一下vue官方文档</p><blockquote><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用 <strong>“就地更新”</strong>的策略。<br>如果数据项的顺序被改变，Vue 将<strong>不会移动</strong>DOM元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。</p></blockquote><p><strong>即当不适用key时，vue更倾向于复用DOM，尝试改变数据层面而不是去操作DOM层面</strong><br>但文档上提出来这个模式的使用范围：</p><blockquote><p>这个默认的模式是高效的，但是只适用于<strong>不依赖子组件状态或临时DOM状态</strong>的列表渲染输出。</p></blockquote><p>我们来看个例子，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test-comp</span> <span class="attr">:data</span>=<span class="string">"item"</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in itemsArray"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">test-comp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handle"</span>&gt;</span>unshift first<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件 test-comp</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; data.word &#125;&#125; - &#123;&#123; data.id &#125;&#125; - &#123;&#123; data.date &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请填写"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>文档中提到了<strong>临时DOM状态</strong>，这个例子里我们看子组件里的input输入框，该输入框没有绑定Vue实例中的任何数据，也就是说他是独立于当前应用程序的状态<br>如果我们在框中输入内容，那么这个内容将会被暂时存储在临时DOM状态中</p></blockquote><p><img src="/img/vue-for-key.png" alt="图1"></p><blockquote><p>更改itemsArray数组元素顺序</p></blockquote><p>我们随便输入一些到输入框中，我们通过底下的unshift first 按钮去改变顺序，在数据头部增加一组ID为11的数据<br><img src="/img/vue-for-key2.png" alt="图2"><br><strong>可以看到input输入框不会随着数组顺序的改变而变化</strong><br>为何？这就是上面说的就地更新，改变数组元素顺序并没有移动DOM元素，而是数据发生变化。</p><p>于是，我们把key属性加上</p><blockquote><p>使用 key 时，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test-comp</span> <span class="attr">:data</span>=<span class="string">"item"</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in itemsArray"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">test-comp</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但结果并没有变化<br><strong>由于这里的key值只是采用了当前项的索引，当数组数据改变时，index并没有变化，只是传入的item发生了改变，所以输入框的内容还是不会改变</strong></p><p>我们改用数据项的id作为key值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test-comp</span> <span class="attr">:data</span>=<span class="string">"item"</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in itemsArray"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">test-comp</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/img/vue-for-key3.png" alt="图3"><br><strong>id是每项数据的唯一标识，能够确保每项的key是独特唯一的，vue能正确跟踪key变化而重新排列元素顺序</strong></p><p>也就是说，我们应该尽可能地使用节点数据的<strong>唯一ID</strong><br>这样做Vue可以更准确地跟踪每个节点的身份并更新组件状态，并且能够重用和重新排列现有元素</p><blockquote><p><strong>注意</strong>: 不要使用<strong>对象</strong>或<strong>数组</strong>之类的<strong>非基本类型值</strong>作为v-for的key。<br>接受的值为：number | string | boolean (2.4.2 新增) | symbol (2.5.12 新增)<br>重复的 key 会造成渲染错误</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们在用v-for指令渲染列表时，如果没有定义 &lt;strong&gt;v-bind:key&lt;/strong&gt;，那么会得到错误提示，&lt;br&gt;可能你会不以为然地加上就万事大吉了&lt;br&gt;但，在某些情况下还是要小心为妙&lt;/p&gt;
&lt;p&gt;先来看一下vue官方文档&lt;/p&gt;
&lt;blockqu
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="http://yoursite.com/2021/01/05/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2021/01/05/跨域/</id>
    <published>2021-01-05T06:03:25.000Z</published>
    <updated>2021-01-06T02:15:25.318Z</updated>
    
    <content type="html"><![CDATA[<p><strong>跨域</strong>是浏览器基于<strong>同源策略</strong>的一种安全手段</p><blockquote><p><strong>同源策略</strong>   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是一种约定，是浏览器最核心也最基本的安全功能</span><br><span class="line">用于隔离潜在恶意文件的安全机制，通常不允许不同源之间的读操作</span><br></pre></td></tr></table></figure><blockquote><p><strong>同源( Sameoriginpolicy )</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">协议相同 protocol</span><br><span class="line">主机相同 host</span><br><span class="line">端口相同 port</span><br></pre></td></tr></table></figure><table><thead><tr><th>url-1</th><th>url-2</th><th align="center">允许通信</th><th align="center">说明</th></tr></thead><tbody><tr><td>http:<a href="http://www.example.com/a.js" target="_blank" rel="noopener">www.example.com/a.js</a></td><td>http:<a href="http://www.example.com/lab/b.js" target="_blank" rel="noopener">www.example.com/lab/b.js</a></td><td align="center">✅</td><td align="center">同一域名，不同文件路径</td></tr><tr><td>http:<a href="http://www.example.com:8080/a.js" target="_blank" rel="noopener">www.example.com:8080/a.js</a></td><td>http:<a href="http://www.example.com/c.js" target="_blank" rel="noopener">www.example.com/c.js</a></td><td align="center">❎</td><td align="center">同一域名，端口不同</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="https://www.example.com/c.js" target="_blank" rel="noopener">https://www.example.com/c.js</a></td><td align="center">❎</td><td align="center">同一域名，协议不同</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="https://192.169.2xx.2x/b.js" target="_blank" rel="noopener">https://192.169.2xx.2x/b.js</a></td><td align="center">❎</td><td align="center">域名和域名对应相同的ip</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://www.demo.com/c.js" target="_blank" rel="noopener">http://www.demo.com/c.js</a></td><td align="center">❎</td><td align="center">主域不同</td></tr><tr><td><a href="http://www.example.com/a.js" target="_blank" rel="noopener">http://www.example.com/a.js</a></td><td><a href="http://x.example.com/c.js" target="_blank" rel="noopener">http://x.example.com/c.js</a></td><td align="center">❎</td><td align="center">子域不同</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.xxx.com 中 www是顶级域名，xxx.com是二级域名（主域名）</span><br><span class="line">aaa.xxx.com 中 aaa则是分域名（子域）</span><br></pre></td></tr></table></figure><blockquote><p>注意-跨域是浏览器出于安全性做的限制<br><strong>也就是说，非同源的请求就会产生跨域</strong></p></blockquote><blockquote><p><strong>解决方法</strong></p></blockquote><ul><li>JSONP</li><li>document.domain + iframe</li><li>window.name + iframe</li><li>location.hash + iframe</li><li>postMessage</li><li>CORS</li><li>Nginx代理</li><li>nodejs中间件代理</li><li>webSocket协议</li></ul><blockquote><p><strong>JSONP</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  只支持GET请求 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, callback, success</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.url = url;</span><br><span class="line">    script.async = <span class="literal">true</span>;</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    <span class="built_in">window</span>[callback] = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        success &amp;&amp; success(data);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在vue项目中，一般关注 CORS / proxy<br><strong>CORS</strong>, 跨域资源共享（Cross-origin Resource Sharing）, 是一个系统</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由一系列传输的HTTP头组成</span><br><span class="line">&#x3D;&gt;(HTTP HEADERS)</span><br><span class="line"></span><br><span class="line">！服务端需打开这个限制 ！</span><br><span class="line">Access-Control-Allow-Origin: * | &lt;origin&gt; 指定一个可访问资源的URI</span><br></pre></td></tr></table></figure><p>如果服务端未使用*, 而是指定了一个域，那么为了向客户端表明服务器的返回会根据Origin请求头而有不同, 即对不同源返回不同的内容<br>必须在<strong>Vary</strong>响应头中包含Origin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: &lt;origin&gt;</span><br><span class="line">Vary: Origin</span><br></pre></td></tr></table></figure><blockquote><p>Simple requests（简单请求）</p></blockquote><p>使用方法： GET / HEAD / POST<br>Content-type值的限制</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><blockquote><p>Preflighted requests（预检请求）</p></blockquote><p>基于<strong>OPTIONS</strong>方法进行过滤，发起一个预检请求到服务器，以获知是否允许该实际请求<br>作用：避免跨域请求对服务器的用户数据产生未预期的影响</p><p>OPTIONS请求通过<strong>Access-Control-Request-Method</strong>告知实际请求使用的方法<br>服务端返回响应<strong>Access-Control-Allow-Methods</strong>表示允许客户端使用的方法发起请求</p><blockquote><p><strong>网络代理</strong><br>运行一个通过这个服务与另一个网络终端进行非直接的连接</p></blockquote><ol><li><p>如果是通过vue-cli搭建工具，可通过<strong>webpack</strong>起一个本地服务器作为请求代理对象<br>但上线时web应用和接口服务器不在一起，还是会跨域</p></li><li><p>服务器实现代理请求转发，以<strong>express</strong>框架为例</p></li><li><p>通过配置<strong>nginx</strong>实现代理</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;跨域&lt;/strong&gt;是浏览器基于&lt;strong&gt;同源策略&lt;/strong&gt;的一种安全手段&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;同源策略&lt;/strong&gt;   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ts</title>
    <link href="http://yoursite.com/2020/11/19/ts/"/>
    <id>http://yoursite.com/2020/11/19/ts/</id>
    <published>2020-11-19T08:01:01.000Z</published>
    <updated>2020-11-19T08:01:01.257Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ts-基础类型</title>
    <link href="http://yoursite.com/2020/11/16/ts-md/"/>
    <id>http://yoursite.com/2020/11/16/ts-md/</id>
    <published>2020-11-16T02:36:12.000Z</published>
    <updated>2020-11-16T06:40:40.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>常见类型</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a:number &#x3D; 1</span><br><span class="line">let hex:number &#x3D; 0x14</span><br><span class="line">let b:string &#x3D; &#39;b&#39;</span><br><span class="line">let c:boolean &#x3D; false</span><br><span class="line">let d:number[] &#x3D; [1,2,3]</span><br><span class="line">let e:Array&lt;String&gt; &#x3D; [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]</span><br></pre></td></tr></table></figure><blockquote><p><strong>元祖类型 Tuple</strong> </p></blockquote><p>表示一个已知元素数量和类型数组，各元素类型不必相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let x:[number, string]   </span><br><span class="line">x &#x3D; [2, &#39;a&#39;] ✅</span><br><span class="line">x &#x3D; [&#39;a&#39;, 3] ❎</span><br></pre></td></tr></table></figure><p>当访问越界元素时，会使用联合类型替代</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x[3] &#x3D; &#39;b&#39;      &#x2F;&#x2F; ✅ string可赋值给string | number</span><br><span class="line">x[5].toString() &#x2F;&#x2F; ✅ string | number 都有toString()</span><br><span class="line">x[6] &#x3D; true     &#x2F;&#x2F; ❎ 类型不符合</span><br></pre></td></tr></table></figure><p>❌ ts 3.1版本之后，访问越界元素会报错</p><blockquote><p><strong>枚举类型</strong></p></blockquote><p>默认情况下，<strong>元素值从0开始，也可手动赋值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    Red &#x3D; 1,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供便利：由枚举值得到属性名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let c: Color &#x3D; Color.Green</span><br><span class="line">let colorName:string &#x3D; Color[2]</span><br></pre></td></tr></table></figure><blockquote><p><strong>any类型</strong> 任意类型</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let notSure:any &#x3D; 4</span><br><span class="line">notSure &#x3D; &#96;maybe a string instead&#96;</span><br></pre></td></tr></table></figure><p>对现有代码进行改写时，any类型十分有用，允许你在编译时可选择地包含或移除类型检查。<br>并且当只知道一部分数据的类型时，any 类型也是有用的</p><blockquote><p><strong>void</strong> 无任何类型</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function xxx():void &#123;</span><br><span class="line">    &#x2F;&#x2F; 无返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个 void  变量无意义，只能赋给  null | undefined </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let unusable:void &#x3D; null &#x2F;&#x2F; 无意义</span><br><span class="line">let unusable:void &#x3D; undefined &#x2F;&#x2F; 无意义</span><br></pre></td></tr></table></figure><blockquote><p><strong>null &amp; undefined</strong>  任意类型</p></blockquote><p>默认情况下 null 和 undefined 是所有类型的<strong>子类型</strong><br><strong>子类型可以赋值给父类型</strong>，像下面这个例子，null和undefined赋值给number类型的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let u:undefined &#x3D; undefined</span><br><span class="line">let n:null &#x3D; undefined</span><br><span class="line"></span><br><span class="line">let num:number &#x3D;3</span><br><span class="line">num &#x3D; null</span><br></pre></td></tr></table></figure><p>常规编译不出错<br>严格编译 <strong>tsc xxx.ts –strictNullChecks</strong> 将会检查null，从而规避一些问题</p><blockquote><p><strong>联合类型</strong>  任意类型</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let num:number | null &#x3D; 2</span><br></pre></td></tr></table></figure><blockquote><p><strong>never</strong> 那些永不存在的值的类型</p></blockquote><p>是<strong>任意类型的子类型</strong>，可以赋值给任何类型<br><strong>别的类型都不是never的子类型，不可赋值给never</strong><br>常用于<strong>抛出一些异常</strong>或<strong>没有返回值的函数表达式</strong>或<strong>箭头函数表达式的返回值类型</strong></p><p>返回never的函数必须存在无法达到的终点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function error(message:string):never &#123;</span><br><span class="line">    throw new Error(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fail () &#123;</span><br><span class="line">    return error(&#39;sth. failed&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function infiniteLoop():never &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>object 非原始类型，除number/string/boolean/numm/symbol/undefined之外的类型</strong></p></blockquote><p>类似object.create() API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare function create(o:object|null):void</span><br><span class="line">create(&#123;prop: 0&#125;) </span><br><span class="line">create(null)</span><br><span class="line">create(42)          ❎</span><br><span class="line">create(false)       ❎</span><br><span class="line">create(undefined)   ❎</span><br></pre></td></tr></table></figure><blockquote><p><strong>类型断言</strong></p></blockquote><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。<br>通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。<br>类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。<br>它没有运行时的影响，只是在编译阶段起作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let someValue:any &#x3D; &#39;this is a string&#39;</span><br><span class="line">someValue.length &#x2F;&#x2F; &#x2F;&#x2F; 此时找不到.length</span><br><span class="line"></span><br><span class="line">let strLength:number&#x3D;(&lt;string&gt;someValue).length</span><br><span class="line">let strLength:number&#x3D;(someValue as string).length</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;常见类型&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack探路</title>
    <link href="http://yoursite.com/2018/01/12/webpack%E6%8E%A2%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/01/12/webpack探路/</id>
    <published>2018-01-12T05:54:08.000Z</published>
    <updated>2018-01-12T06:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>###webpack初步理解</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-eg</span><br><span class="line"><span class="built_in">cd</span> webpack-eg</span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>###提交二<br>#关键词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server 代理</span><br><span class="line">source-map</span><br><span class="line">部署上线 webpack-prod.config.js</span><br><span class="line">分离app.js 和 第三方库</span><br><span class="line">vendor: [] &#x2F; filename: &#39;[name].js&#39;</span><br><span class="line">uglifyJs CommonsChunkPlugin</span><br><span class="line">babel-loader</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>###提交三<br>#关键词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">生成多页面</span><br><span class="line">多入口</span><br><span class="line">templatesindex.html &#x2F; mobile.html</span><br><span class="line">生成hash名称的script 来防止缓存</span><br><span class="line">output filename: [name].[hash].js</span><br></pre></td></tr></table></figure><p>###提交四<br>#关键词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start命令指定 webpack.dev.js</span><br><span class="line">区分生产环境和开发环境 </span><br><span class="line">保留通用配置 webpack.common.js</span><br><span class="line">webpack-merge</span><br></pre></td></tr></table></figure><p>具体代码移步–<a href="https://github.com/karencxx/webpack-demo.git" target="_blank" rel="noopener">https://github.com/karencxx/webpack-demo.git</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###webpack初步理解&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在note上添加上vue-router</title>
    <link href="http://yoursite.com/2017/12/13/vue-router/"/>
    <id>http://yoursite.com/2017/12/13/vue-router/</id>
    <published>2017-12-13T07:18:24.000Z</published>
    <updated>2017-12-14T03:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>把note项目改造了一下，采用路由的方式<br>单页面应用</p><h3 id="记录一下"><a href="#记录一下" class="headerlink" title="记录一下"></a>记录一下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在src下新建文件夹router</span><br><span class="line"></span><br><span class="line">在main.js中</span><br><span class="line">import router from <span class="string">'./router'</span></span><br><span class="line">import Vue from <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">Vue.use(router)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="之前的写法"><a href="#之前的写法" class="headerlink" title="之前的写法"></a>之前的写法</h3><pre><code>import router from &#39;./router&#39;import Vue from &#39;vue&#39;Vue.use(router)new Vue({    store, //vuex    el: &#39;#app&#39;,    router,    template: &#39;&lt;App/&gt;&#39;,    components: { App } //import App from &#39;./App&#39;})</code></pre><h3 id="现在的写法"><a href="#现在的写法" class="headerlink" title="现在的写法"></a>现在的写法</h3><pre><code>new Vue({    store, //vuex    el: &#39;#app&#39;,    router,    ...App})</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.vue</span><br><span class="line"></span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h3 id="路由文件-router-index-js"><a href="#路由文件-router-index-js" class="headerlink" title="路由文件 router/index.js"></a>路由文件 router/index.js</h3><pre><code>import Router from &#39;vue-router&#39;import Index from &#39;@/views/Index&#39;Vue.use(Router)export default new Router({    routes: [    {        path: &#39;/index&#39;,        name: &#39;index&#39;,        component: Index    },{    }]})</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">配置完router后，发现url为 http://localhost:8080/<span class="comment">#/</span></span><br><span class="line">在此就要了解一下 vue-router 是默认<span class="built_in">hash</span>模式的，</span><br><span class="line">也就是说当url改变时，页面不会重新加载，相当于锚点跳转</span><br><span class="line">如果不想要这种<span class="built_in">hash</span>模式，可以采用history.pushState API完成跳转</span><br></pre></td></tr></table></figure><h3 id="vue2-0-路由选择-Modes"><a href="#vue2-0-路由选择-Modes" class="headerlink" title="vue2.0 路由选择 Modes"></a>vue2.0 路由选择 Modes</h3><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new Router(&#123;</span><br><span class="line"><span class="built_in">history</span>: <span class="literal">true</span>,</span><br><span class="line">routes:[]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre><h3 id="但需要注意的是，这种情况需要后端的支持，比如locahost-8080-login-id这种就会找不到"><a href="#但需要注意的是，这种情况需要后端的支持，比如locahost-8080-login-id这种就会找不到" class="headerlink" title="但需要注意的是，这种情况需要后端的支持，比如locahost:8080/login/:id这种就会找不到"></a>但需要注意的是，这种情况需要后端的支持，比如locahost:8080/login/:id这种就会找不到</h3><pre><code>暂时处理方法可以是 定义一个routes * 当所有找不到的path时 都指向404.vue</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把note项目改造了一下，采用路由的方式&lt;br&gt;单页面应用&lt;/p&gt;
&lt;h3 id=&quot;记录一下&quot;&gt;&lt;a href=&quot;#记录一下&quot; class=&quot;headerlink&quot; title=&quot;记录一下&quot;&gt;&lt;/a&gt;记录一下&lt;/h3&gt;&lt;figure class=&quot;highlight bas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>运用vuex构建note</title>
    <link href="http://yoursite.com/2017/11/28/vuex/"/>
    <id>http://yoursite.com/2017/11/28/vuex/</id>
    <published>2017-11-28T10:12:34.000Z</published>
    <updated>2017-12-13T07:19:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>vuex探究</p><p>最近研究了下vue+vuex,正好看到了国外的一篇文章(如何构建一个笔记的单页应用),就着练手了下,也从中发现了一些问题并解决了。<br>–国外文章地址：<a href="https://coligo.io/learn-vuex-by-building-notes-app/" target="_blank" rel="noopener">https://coligo.io/learn-vuex-by-building-notes-app/</a><br>在此记录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体安装操作什么的就不一一详细说明了。</span><br></pre></td></tr></table></figure><h3 id="那篇文章的vue版本应该是1-0，而本地项目安装的版本为2-0，所以练习的过程中碰到了一些问题。"><a href="#那篇文章的vue版本应该是1-0，而本地项目安装的版本为2-0，所以练习的过程中碰到了一些问题。" class="headerlink" title="那篇文章的vue版本应该是1.0，而本地项目安装的版本为2.0，所以练习的过程中碰到了一些问题。"></a>那篇文章的vue版本应该是1.0，而本地项目安装的版本为2.0，所以练习的过程中碰到了一些问题。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.0使用了mapActions,mapGetters</span><br><span class="line">dispatch =&gt; commit</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; addNote, deleteNote, toggleFavorite &#125; from <span class="string">'../vuex/actions'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  vuex: &#123;</span><br><span class="line">    getters: &#123;</span><br><span class="line">      activeNote: state =&gt; state.activeNote</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">      addNote,</span><br><span class="line">      deleteNote,</span><br><span class="line">      toggleFavorite</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要改成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions, mapGetters &#125; from <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">methods: &#123;</span><br><span class="line">...mapActions([<span class="string">'editNote'</span>, <span class="string">'editContent'</span>])</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">...mapGetters([<span class="string">'activeNoteText'</span>, <span class="string">'activeNoteContent'</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>actions.js的引入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import * as actions from <span class="string">'./actions'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default new Vuex.Store(&#123; actions&#125;)</span><br><span class="line"></span><br><span class="line">就不需要</span><br><span class="line">import &#123; addNote, deleteNote, toggleFavorite &#125; from <span class="string">'../vuex/actions'</span></span><br><span class="line"></span><br><span class="line">在main.js注入store</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">还有个数据绑定的小问题</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> @input=<span class="string">"editNote"</span> v-model=<span class="string">"activeNoteText"</span>&gt;</span><br><span class="line">这时候会报一个错：Computed property <span class="string">"activeNoteText"</span> was assigned to but it has no setter.</span><br></pre></td></tr></table></figure><p>stackoverflow上有段解释 (<a href="https://stackoverflow.com/questions/46106037/vuex-computed-property-name-was-assigned-to-but-it-has-no-setter" target="_blank" rel="noopener">https://stackoverflow.com/questions/46106037/vuex-computed-property-name-was-assigned-to-but-it-has-no-setter</a>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If you<span class="string">'re going to v-model a computed, it needs a setter. Whatever you want it to do with the updated value (probably write it to the $store, considering that'</span>s what your getter pulls it from) you <span class="keyword">do</span> <span class="keyword">in</span> the setter.</span><br><span class="line"></span><br><span class="line">If writing it back to the store happens via form submission, you don<span class="string">'t want to v-model, you just want to set :value.</span></span><br></pre></td></tr></table></figure><p>具体代码在 <a href="https://github.com/karencxx/vue.git" target="_blank" rel="noopener">https://github.com/karencxx/vue.git</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vuex探究&lt;/p&gt;
&lt;p&gt;最近研究了下vue+vuex,正好看到了国外的一篇文章(如何构建一个笔记的单页应用),就着练手了下,也从中发现了一些问题并解决了。&lt;br&gt;–国外文章地址：&lt;a href=&quot;https://coligo.io/learn-vuex-by-build
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue项目构建</title>
    <link href="http://yoursite.com/2017/11/27/vue%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
    <id>http://yoursite.com/2017/11/27/vue项目构建/</id>
    <published>2017-11-27T06:15:37.000Z</published>
    <updated>2017-12-21T09:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>###记录一下</p><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前提: node和npm环境</span><br></pre></td></tr></table></figure><p>安装vue-cli脚手架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init webpack [project name]</span><br><span class="line">初始化项目，整个项目是基于webpack，项目信息具体步骤如下图</span><br></pre></td></tr></table></figure><p><img src="/img/vue-init.png" alt="vue init project"></p><p>或者 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack [project name]</span><br></pre></td></tr></table></figure><p>安装项目依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进入项目所在文件夹，执行npm install</span><br></pre></td></tr></table></figure><p>运行项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run dev 热部署项目</span><br><span class="line"></span><br><span class="line">其中的“run”对应的是package.json文件中，scripts字段中的dev，也就是 node build/dev-server.js命令的一个快捷方式。</span><br></pre></td></tr></table></figure><p>项目文件结构<br><img src="/img/vue-structure.png" alt="vue project structure"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###记录一下&lt;/p&gt;
&lt;hr&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>1123-2</title>
    <link href="http://yoursite.com/2017/11/23/1123-2/"/>
    <id>http://yoursite.com/2017/11/23/1123-2/</id>
    <published>2017-11-23T03:21:38.000Z</published>
    <updated>2017-11-23T07:49:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>Express 路由</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">路由,Routing是由一个URI和一个特定的HTTP方法组成的，涉及到应用如何相应客户端对某个网站节点的访问。</span><br></pre></td></tr></table></figure><p>结构组成:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.METHOD(PATH, HANDLER)</span><br><span class="line">app是一个express实例；METHOD是某个HTTP请求方式中的一个；PATH是服务器端的路径;HANDLER是当路由匹配到时需要执行的函数</span><br></pre></td></tr></table></figure><p>Express 托管静态文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过内置的express.static可以方便地托管静态文件，例如图片，css，JavaScript文件等</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将静态资源文件所在的目录座位参数传递给express.static中间件就可以提供静态资源文件的访问了。</span><br><span class="line">例如：在public目录放置了静态资源，设置app.use(express.static(<span class="string">'public'</span>))，就可以通过localhost:3000/images/xxx.png访问了</span><br><span class="line"></span><br><span class="line">还可以指定一个挂载前缀，app.use(<span class="string">'/static'</span>, express.static(<span class="string">'public'</span>)),访问路径为localhost:3000/static/images/xxx.png</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 文件路径是相对路径，即存放静态文件的目录名不会出现在url中</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在express中404并不是一个error,因此错误处理器中间件捕获不到404，需要单独拎出来处理</span><br><span class="line">(404相对来说只是功能未完全实现)</span><br><span class="line">app.use(<span class="keyword">function</span>(req, res, next)&#123;</span><br><span class="line">res.status(404).send(<span class="string">'404 not find'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置错误处理器,多一个err参数</span><br><span class="line">app.use(<span class="keyword">function</span>(err, req, res, next)&#123;</span><br><span class="line">res.status(500).send(<span class="string">'error'</span>+ err.stack)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字符串模式的路由路径</span><br><span class="line">?、+、*、()是正则表达式的子集</span><br><span class="line"></span><br><span class="line">/ab?<span class="built_in">cd</span> -- 匹配abcd、acd</span><br><span class="line">/ab+<span class="built_in">cd</span> -- 匹配abcd、abbcd、abbbcd等</span><br><span class="line">/ab*<span class="built_in">cd</span> -- 匹配abcd、abxcd、abjfkjfcd等</span><br><span class="line">/ab(<span class="built_in">cd</span>)?e -- 匹配abe、abcde</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.route() 创建路由路径的链式路由句柄。</span><br><span class="line"></span><br><span class="line">app.route(<span class="string">'/test'</span>)</span><br><span class="line">.get(<span class="keyword">function</span>(req, res)&#123;</span><br><span class="line">res.send(<span class="string">'test a'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.post(<span class="keyword">function</span>(req, res)&#123;</span><br><span class="line">res.send(<span class="string">'test b'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可用express.Router类创建模块化、可挂载的路由句柄。</span><br></pre></td></tr></table></figure><p>参考</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.expressjs.com.cn/starter/installing.html</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Express 路由&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;cod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>1123</title>
    <link href="http://yoursite.com/2017/11/23/1123/"/>
    <id>http://yoursite.com/2017/11/23/1123/</id>
    <published>2017-11-23T02:57:57.000Z</published>
    <updated>2017-11-23T03:12:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>Express安装记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前提 -- node环境</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir myapp -- 创建工作目录</span><br><span class="line">cd myapp -- 进入</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -- 初始化package.json，依次enter键就好了，但注意entry point所指向的文件(在此命名为app.js)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save --安装express</span><br><span class="line">npm install express -- 临时安装</span><br></pre></td></tr></table></figure><p>入门第一步 – hello world</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd myapp -- 进入myapp目录，创建app.js</span><br></pre></td></tr></table></figure><p>输入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;)</span><br><span class="line">var app &#x3D; express()</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, function(req, res)&#123;</span><br><span class="line">res.send(&#39;Hello World&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var server &#x3D; app.listen(3000, function()&#123;</span><br><span class="line">var host &#x3D; server.address().address</span><br><span class="line">var host &#x3D; server.address().port</span><br><span class="line">console.log(&#39;Example app listening at http:&#x2F;&#x2F;%s:%s&#39;, host, port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 代码解释: 启动一个服务并监听从3000端口进入的所有连接服务。他将对所有(&#x2F;)URL或路由返回&#39;Hello World&#39;的字符串</span><br><span class="line">对其他路径返回404</span><br></pre></td></tr></table></figure><p>启动应用</p><pre><code class="base">    node app.js</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Express安装记录&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>1121</title>
    <link href="http://yoursite.com/2017/11/21/1121/"/>
    <id>http://yoursite.com/2017/11/21/1121/</id>
    <published>2017-11-21T09:26:02.000Z</published>
    <updated>2017-11-21T09:44:20.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">得过且过</span><br><span class="line">感觉有点漫无目的</span><br><span class="line">给自己定的小目标也没有落实</span><br><span class="line">毫无头绪，不知道从何开头</span><br><span class="line">胡思乱想 乱七八糟的</span><br><span class="line">看来得好好规划了</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>create a plugin</title>
    <link href="http://yoursite.com/2017/11/17/create-a-plugin/"/>
    <id>http://yoursite.com/2017/11/17/create-a-plugin/</id>
    <published>2017-11-17T06:39:10.000Z</published>
    <updated>2017-11-17T08:46:48.000Z</updated>
    
    <content type="html"><![CDATA[<iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/AntBody/138zf8kk/embedded/js,html,css,result/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe scrolling=&quot;no&quot; width=&quot;100%&quot; height=&quot;300&quot; src=&quot;https://jsfiddle.net/AntBody/138zf8kk/embedded/js,html,css,result/dark&quot; frameborder=&quot;0
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>1116</title>
    <link href="http://yoursite.com/2017/11/16/1116/"/>
    <id>http://yoursite.com/2017/11/16/1116/</id>
    <published>2017-11-16T03:13:03.000Z</published>
    <updated>2017-11-22T03:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>了解</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dubbo 分布式服务框架 远程服务调用</span><br><span class="line">Zookeeper 选举机制 paxos算法</span><br></pre></td></tr></table></figure><p>最近小目标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.JS、ES6、css3</span><br><span class="line">2.插件编写</span><br><span class="line">3.css sprite雪碧图</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;了解&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭建步骤</title>
    <link href="http://yoursite.com/2017/11/15/my-first-article/"/>
    <id>http://yoursite.com/2017/11/15/my-first-article/</id>
    <published>2017-11-15T06:23:45.000Z</published>
    <updated>2017-11-16T03:06:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下:)</p><ol><li>前提：本地 node git 环境</li><li>安装hexo – 打开终端，输入 sudo npm install -g hexo </li><li>初始化hexo – 本地目录下创建名为hexo的文件夹，终端定位到该目录下，执行命令：nexo init</li><li>安装依赖 – npm install</li><li>生成静态页面 – hexo generate</li><li>开启服务 – hexo server 本地监听 localhost:4000</li><li>远程创建repository – your_user_name.github.io (与github用户名一致)</li><li>安装git部署器 – npm install hexo-deployer-git –save</li><li>修改配置文件 – 打开_config.yml 在文件末尾修改<pre><code> deploy type: git  repo: 你的repository地址        如 https://github.com/xxx/xxx.github.io.git branch: master</code></pre></li><li>部署 – hexo deploy</li><li>效果 – 打开网站 <a href="https://xxx.github.io/" target="_blank" rel="noopener">https://xxx.github.io</a></li><li>发表文章 – hexo new ‘文章名’</li><li>编辑完，重新生成并部署 – hexo clean hexo g hexo d</li><li>hexo在hexo目录下执行<br>hexo命令缩写     <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g(generate) </span><br><span class="line">hexo d(deploy) </span><br><span class="line">hexo s(server) </span><br><span class="line">hexo n(new)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下:)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前提：本地 node git 环境&lt;/li&gt;
&lt;li&gt;安装hexo – 打开终端，输入 sudo npm install -g hexo &lt;/li&gt;
&lt;li&gt;初始化hexo – 本地目录下创建名为hexo的文件夹，终端定位到该目录下，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/11/15/hello-world/"/>
    <id>http://yoursite.com/2017/11/15/hello-world/</id>
    <published>2017-11-15T03:44:22.000Z</published>
    <updated>2017-11-15T03:44:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
